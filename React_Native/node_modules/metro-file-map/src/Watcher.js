"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true,
});
exports.Watcher = void 0;

var _watchman = _interopRequireDefault(require("./crawlers/watchman"));

var _node = _interopRequireDefault(require("./crawlers/node"));

var _WatchmanWatcher = _interopRequireDefault(
  require("./watchers/WatchmanWatcher")
);

var _FSEventsWatcher = _interopRequireDefault(
  require("./watchers/FSEventsWatcher")
);

var _NodeWatcher = _interopRequireDefault(require("./watchers/NodeWatcher"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @format
 *
 */
// $FlowFixMe[untyped-import] - it's a fork: https://github.com/facebook/jest/pull/10919
const debug = require("debug")("Metro:Watcher");

const MAX_WAIT_TIME = 240000;

class Watcher {
  _backends = [];

  constructor(options) {
    this._options = options;
  }

  async crawl() {
    var _this$_options$perfLo;

    (_this$_options$perfLo = this._options.perfLogger) === null ||
    _this$_options$perfLo === void 0
      ? void 0
      : _this$_options$perfLo.point("crawl_start");
    const options = this._options;

    const ignore = (filePath) => options.ignore(filePath);

    const crawl = options.useWatchman ? _watchman.default : _node.default;
    const crawlerOptions = {
      abortSignal: options.abortSignal,
      computeSha1: options.computeSha1,
      data: options.initialData,
      enableSymlinks: options.enableSymlinks,
      extensions: options.extensions,
      forceNodeFilesystemAPI: options.forceNodeFilesystemAPI,
      ignore,
      perfLogger: options.perfLogger,
      rootDir: options.rootDir,
      roots: options.roots,
    };

    const retry = (error) => {
      if (crawl === _watchman.default) {
        options.console.warn(
          "metro-file-map: Watchman crawl failed. Retrying once with node " +
            "crawler.\n" +
            "  Usually this happens when watchman isn't running. Create an " +
            "empty `.watchmanconfig` file in your project's root folder or " +
            "initialize a git or hg repository in your project.\n" +
            "  " +
            error.toString()
        );
        return (0, _node.default)(crawlerOptions).catch((e) => {
          throw new Error(
            "Crawler retry failed:\n" +
              `  Original error: ${error.message}\n` +
              `  Retry error: ${e.message}\n`
          );
        });
      }

      throw error;
    };

    const logEnd = (result) => {
      var _this$_options$perfLo2;

      (_this$_options$perfLo2 = this._options.perfLogger) === null ||
      _this$_options$perfLo2 === void 0
        ? void 0
        : _this$_options$perfLo2.point("crawl_end");
      return result;
    };

    try {
      return crawl(crawlerOptions).catch(retry).then(logEnd);
    } catch (error) {
      return retry(error).then(logEnd);
    }
  }

  async watch(onChange) {
    var _this$_options$perfLo3;

    const { extensions, ignorePattern, useWatchman } = this._options; // WatchmanWatcher > FSEventsWatcher > sane.NodeWatcher

    const WatcherImpl = useWatchman
      ? _WatchmanWatcher.default
      : _FSEventsWatcher.default.isSupported()
      ? _FSEventsWatcher.default
      : _NodeWatcher.default;
    let watcher = "node";

    if (WatcherImpl === _WatchmanWatcher.default) {
      watcher = "watchman";
    } else if (WatcherImpl === _FSEventsWatcher.default) {
      watcher = "fsevents";
    }

    debug(`Using watcher: ${watcher}`);
    (_this$_options$perfLo3 = this._options.perfLogger) === null ||
    _this$_options$perfLo3 === void 0
      ? void 0
      : _this$_options$perfLo3.annotate({
          string: {
            watcher,
          },
        });

    const createWatcherBackend = (root) => {
      const watcherOptions = {
        dot: true,
        glob: [
          // Ensure we always include package.json files, which are crucial for
          /// module resolution.
          "**/package.json",
          ...extensions.map((extension) => "**/*." + extension),
        ],
        ignored: ignorePattern,
        watchmanDeferStates: this._options.watchmanDeferStates,
      };
      const watcher = new WatcherImpl(root, watcherOptions);
      return new Promise((resolve, reject) => {
        const rejectTimeout = setTimeout(
          () => reject(new Error("Failed to start watch mode.")),
          MAX_WAIT_TIME
        );
        watcher.once("ready", () => {
          clearTimeout(rejectTimeout);
          watcher.on("all", onChange);
          resolve(watcher);
        });
      });
    };

    this._backends = await Promise.all(
      this._options.roots.map(createWatcherBackend)
    );
  }

  async close() {
    await Promise.all(this._backends.map((watcher) => watcher.close()));
  }
}

exports.Watcher = Watcher;
